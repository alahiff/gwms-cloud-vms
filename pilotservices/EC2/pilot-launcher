#!/usr/bin/python

import os
import sys
import signal

import glideinwms_pilot.email
import glideinwms_pilot.glideinwms_tarfile
import glideinwms_pilot.simple_logging
import glideinwms_pilot.user_data
import glideinwms_pilot.version_info
import glideinwms_pilot.vm_utils

from glideinwms_pilot.errors import PilotError
from glideinwms_pilot.errors import TimeoutError

# Pilot Environment class
class PilotEnvironment(dict):
    """
    Customized dictionary for defining the environment that will be used for
    launching the glideinWMS pilot
    """
    def __init__(self, config):
        self["OSG_GRID"] = "/usr/local/osg/wn_client/current"
        self["OSG_APP"] = "/mnt/app"
        self["OSG_DATA"] = "/mnt/data"
        self["VOMS_PROXY_INFO_DONT_VERIFY_AC"] = "1"
        self["GLIDEIN_Condor_IDS"] = config.user_ids
        self["X509_USER_PROXY"] = config.proxy_file

    def export(self):
        environment = ""
        template = "export %s=%s; "
        try:
            for key, value in self.items():
                environment += template % (key, value)
        except:
            pass
        return environment

    def __repr__(self): return self.export()

class Config(object):
    def __init__(self):
        self.version = version_info.SERVICE_VERSION
        self.release = version_info.SERVICE_RELEASE
        self.glidein_user = "glidein_pilot"
        self.user_ids = "91234.91234"
        self.home_dir = "/mnt/%s" % self.glidein_user
        self.ini_file = "%s/glidein_userdata" % self.home_dir
        self.userdata_file = "%s/userdata_file" % self.home_dir

        self.default_max_lifetime = 172800 # 48 hours
        self.max_lifetime = self.default_max_lifetime  # can be overriden
        config.disable_shutdown = False

        config.contextualization_type = version_info.CONTEXTUALIZE_TYPE
        if config.contextualization_type.upper() == "EC2":
            config.ec2_url = "http://169.254.169.254/latest/user-data"

    def __str__(self):
        return "Config Object %i.%i" % (int(self.version), int(self.release))


def shutdown_ami(config):
    disable_shutdown = config.disable_shutdown
    if not disable_shutdown:
        shutdown_vm()

def define_cmd(config):
    try:
        pilot_env = PilotEnvironment(config)
        cmd = "%s cd %s; sh glidein_startup.sh %s" % (pilot_env.export(), config.home_dir, config.pilot_args)
    except Exception, ex:
        raise PilotError("Error defining pilot launch command: %s\n" % str(ex))

    return cmd

def retrieve_glidein_startup(config):
    try:
        url = "%s/glidein_startup.sh" % config.factory_url
        script = "%s/glidein_startup.sh" % config.home_dir
        script, _ = urllib.urlretrieve(url, script)
    except Exception, ex:
        raise PilotError("Error retrieving glidein_startup.sh: %s\n" % str(ex))


def handler_max_lifetime(signum, frame):
    raise TimeoutError("Max lifetime (%s) has been exceeded, shutting down...")

def main():
    """
        Perform all the work necessary to launch a glideinWMS pilot which will
        attempt to connect back to the user pool.

        1)  daemonize this script.  This script is lauched via the *nix service
            mechanisms.  We don't want to make it wait forever and we don't
            want it to be attached to a console.
        2)  Get the user data that was passed to the AMI - Currently it is a
            tarball.
        3)  untar the tarball.  The tarball will contain a proxy, the
            glidein_startup.sh script and an ini file containing all the extra
            information needed
        4)  read the ini file
        5)  get the arguments for the glidein_startup.sh script
        6)  create an environment string to pass with final command
        7)  launch the glidein pilot with the appropriate environment
    """
    daemonize("/tmp/pilot.pid")

    ctx = Contextualize()

    # Make GLIDEIN_HOME
    mkdir_p(ctx.config.home_dir)
    chown(ctx.config.user_ids, ctx.config.home_dir)

    log = Logger(config.home_dir)
    log.logit("Hello Dave... I have taken the liberty to daemonize and begin the contextualization process.")

    try:
        # get the user data - should be a tar file
        log.logit("Retrieving user data")
        ctx.retrieve_user_data()

        # untar the user data
        log.logit("Extracting user data")
        ctx.extract_user_data()

        # Set up a safety switch that will automatically terminate this VM if
        # something went wrong and it runs for longer than config.max_lifetime
        signal.signal(signal.SIGALRM, handler_max_lifetime)
        signal.alarm(ctx.MAX_LIFETIME)

        # ensure that the proxy is owned by the correct user
        log.logit("Chowning the VO proxy")
        chown(ctx.config.user_ids, ctx.config.proxy_file)

        # get the glidein_startup.sh script
        log.logit("Retrieving glidein_startup.sh")
        ctx.retrieve_glidein_startup()

        # generate the pilot launch command
        log.logit("Generating the pilot launch command")
        cmd = ctx.define_cmd()

        # launch the pilot
        log.logit("About to execute command: \n%s" % cmd)
        log.logit("===== BEGIN LOGGING EXTERNAL (non-formatted) DATA ======")

        launch_pilot(cmd, log.log, log.log)

        log.logit("===== END LOGGING EXTERNAL (non-formatted) DATA ======")

    except PilotError, ex:
        message = "A PilotError has occured: %s" % str(ex)
        log.log_err(message)
    except TimeoutError, ex:
        message = "Timeout Error occurred.  The Pilot has been running for more than %s seconds" % str(ctx.config.MAX_LIFETIME)
        log.log_err(message)
    except Exception, ex:
        log.log_err("Error launching pilot: %s" % str(ex))

    # turn off the alarm signal since the very next step is to shutdown the VM anyway
    signal.alarm(0)

    # need to figure out how to set up glidein_pilot user to be able to sudo
    shutdown_ami(config)

if __name__ == "__main__":
    main()
