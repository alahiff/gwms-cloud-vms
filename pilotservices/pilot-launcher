#!/usr/bin/python

import os
import signal
import urllib
import ConfigParser

import glideinwms_pilot.vm_utils

from glideinwms_pilot.errors import PilotError
from glideinwms_pilot.errors import TimeoutError
from glideinwms_pilot.errors import ConfigError
from glideinwms_pilot.user_data import retrieve_user_data
from glideinwms_pilot.user_data import extract_user_data
from glideinwms_pilot.config import Config

def shutdown(config):
    disable_shutdown = config.disable_shutdown
    if disable_shutdown:
        config.log.logit("Shutdown has been disabled")
    else:
        glideinwms_pilot.vm_utils.shutdown_vm()

def define_cmd(config):
    try:
        cmd = 'su %s -c "%s cd %s; sh glidein_startup.sh %s"' % \
            (config.glidein_user, config.export_grid_env(), 
             config.home_dir, config.pilot_args)
    except Exception, ex:
        raise PilotError("Error defining pilot launch command: %s\n" % str(ex))

    return cmd

def retrieve_glidein_startup(config):
    try:
        url = "%s/glidein_startup.sh" % config.factory_url
        script = "%s/glidein_startup.sh" % config.home_dir
        script, _ = urllib.urlretrieve(url, script)
    except Exception, ex:
        raise PilotError("Error retrieving glidein_startup.sh: %s\n" % str(ex))

def handler_max_lifetime(signum, frame): # pylint: disable=W0613
    raise TimeoutError("Max lifetime has been exceeded, shutting down...")

def main():
    """
        Perform all the work necessary to launch a glideinWMS pilot which will
        attempt to connect back to the user pool.

        1)  daemonize this script.  This script is lauched via the *nix service
            mechanisms.  We don't want to make it wait forever and we don't
            want it to be attached to a console.
        2)  Get the user data that was passed to the AMI - Currently it is a
            tarball.
        3)  untar the tarball.  The tarball will contain a proxy, the
            glidein_startup.sh script and an ini file containing all the extra
            information needed
        4)  read the ini file
        5)  get the arguments for the glidein_startup.sh script
        6)  create an environment string to pass with final command
        7)  launch the glidein pilot with the appropriate environment
    """
    glideinwms_pilot.vm_utils.daemonize("/tmp/pilot.pid")

    # If config fails, we need to write error to console if available
    try:
        config = Config()
        config.make_directories()
    
        try:
            # chown the log file to the glidein user so that that user can write to it
            glideinwms_pilot.vm_utils.chown(config.user_ids, config.log.get_logfile())
    
            # get the user data - should be a tar file
            config.log.logit("Retrieving user data")
            retrieve_user_data(config)
    
            # untar the user data
            config.log.logit("Extracting user data")
            extract_user_data(config)
    
            # Set up a safety switch that will automatically terminate this VM if
            # something went wrong and it runs for longer than config.max_lifetime
            signal.signal(signal.SIGALRM, handler_max_lifetime)
            config.log.logit("Setting alarm to %s seconds" % config.max_lifetime)
            signal.alarm(int(config.max_lifetime))
    
            # ensure that the proxy is owned by the correct user
            config.log.logit("Chowning the VO proxy")
            glideinwms_pilot.vm_utils.chown(config.user_ids, config.proxy_file)
    
            # get the glidein_startup.sh script
            config.log.logit("Retrieving glidein_startup.sh")
            retrieve_glidein_startup(config)
    
            # generate the pilot launch command
            config.log.logit("Generating the pilot launch command")
            cmd = define_cmd(config)
    
            # launch the pilot
            config.log.logit("About to execute command: \n%s" % cmd)
            config.log.logit("===== BEGIN LOGGING EXTERNAL (non-formatted) DATA ======")
    
            glideinwms_pilot.vm_utils.launch_pilot(cmd, config.log.get_logfile_fd(), config.log.get_logfile_fd())
    
            config.log.logit("===== END LOGGING EXTERNAL (non-formatted) DATA ======")
    
        except PilotError, ex:
            message = "A PilotError has occured: %s" % str(ex)
            config.log.log_err(message)
        except TimeoutError, ex:
            message = "Timeout Error occurred.  The Pilot has been running for more than %s seconds" % str(config.max_lifetime)
            config.log.log_err(message)
        except Exception, ex:
            config.log.log_err("Error launching pilot: %s" % str(ex))
    except ConfigError, ex:
        # we need to figure out how to write to the console
        pass

    # turn off the alarm signal since the very next step is to shutdown the VM anyway
    signal.alarm(0)

    # need to figure out how to set up glidein_pilot user to be able to sudo
    shutdown(config)

if __name__ == "__main__":
    main()
